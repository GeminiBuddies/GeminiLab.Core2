using System;
using System.Text;

namespace GeminiLab.Core2.Text {
    public static class EscapeSequenceConverter {
        private static readonly byte[] DecodeTable = {
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x22, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x5c, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x08, 0xff, 0xff, 0xff, 0x0c, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0a, 0xff,
            0xff, 0xff, 0x0d, 0xff, 0x09, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        };

        private static readonly byte[] EncodeTable = {
            0x30, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x62, 0x74, 0x6e, 0xff, 0x66, 0x72, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0x22, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x5c, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        };

        public static string Decode(string source) => Decode(source.AsSpan());

        public static string Decode(ReadOnlySpan<char> source) {
            int length = source.Length;
            var sb = new StringBuilder(length / 4); // not so likely to be shorter than this.

            int i = 0;
            while (i < length) {
                if (source[i] == '\\') {
                    if (i + 1 == length) {
                        sb.Append('\\');
                        break;
                    }

                    if (source[i + 1] < 128 && DecodeTable[source[i + 1]] < 0xff) {
                        sb.Append((char)DecodeTable[source[i + 1]]);
                        i += 2;
                    } else if (source[i + 1] == 'u') {
                        if (i + 5 >= length) {
                            sb.Append(source.Slice(i));
                            break;
                        }

                        int unicode = 0;
                        for (int it = i + 2; it < i + 6; ++it) {
                            if (!source[it].IsHexadecimalDigit()) {
                                unicode = -1;
                                break;
                            }
                            unicode = unicode * 16 + (source[it] <= '9' ? source[it] - '0' : (source[it] & 0xDF) - 'A' + 10);
                        }

                        if (unicode >= 0) sb.Append((char) unicode);
                        else sb.Append(source.Slice(i, 6));
                        i += 6;
                    } else {
                        sb.Append(source.Slice(i, 2));
                        i += 2;
                    }
                } else {
                    sb.Append(source[i]);
                    ++i;
                }
            }

            return sb.ToString();
        }

        public static string Encode(string source) {
            int length = source.Length;
            var sb = new StringBuilder(length);

            for (int i = 0; i < length; ++i) {
                if (source[i] > 128 || EncodeTable[source[i]] == 0xff) sb.Append(source[i]);
                else {
                    sb.Append('\\');
                    sb.Append((char)EncodeTable[source[i]]);
                }
            }

            return sb.ToString();
        }

        public static string EncodeToAscii(string source) {
            int length = source.Length;
            var sb = new StringBuilder(length);

            for (int i = 0; i < length; ++i) {
                if (source[i] > 128) {
                    sb.Append("\\u");
                    sb.Append($"{(int)source[i]:x4}");
                } else if (EncodeTable[source[i]] == 0xff) {
                    sb.Append(source[i]);
                } else {
                    sb.Append('\\');
                    sb.Append((char)EncodeTable[source[i]]);
                }
            }

            return sb.ToString();
        }
    }
}
